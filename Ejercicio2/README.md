# Ejercicio 2
## 1. Resolver el ejercicio planteado.
Se toma como base el código suministrado por el profesor y se realizan las siguientes modificaciones para completar el ejercicio:

- Se agrega el atributo action a la clase Node para poder determinar la ruta recorrida: Up, Down, Left, Right.
- Se define la clase Problem: se le agregan los atributos de initial (posición inicial), goal (posición objetivo), actions (conjunto de acciones que se pueden realizar).
- En la función find_exit se agrega el diccionario de acciones, donde la clave es el cambio de posición que se debe realizar en el maze y el valor es el nombre de dicho movimiento.
- En la función get_neighbors se modifica la variable neighbors (que era una lista) y se convierte en un diccionario para guardar no solo los vecinos a los cuales se puede mover, sino también la acción que hay que realizar para llegar a ese vecino (Up, Down, Left o Right).
- Finalmente, en la función reconstruct_path, se agregó la lógica para reconstruir también el conjunto de acciones realizadas para llegar de la posición inicial a la final.

- ## 2. ¿Cómo cambia el comportamiento del algoritmo si cambiamos la función de costo?
El código original supone que todos los movimientos cuestan 1, pero este costo no se está teniendo en cuenta para la cola de prioridad usada (la prioridad se está dando según la heurística de la distancia Manhattan). Si se deseara cambiar la heurístrica para tener en cuenta el costo, entonces tendríamos una función de tipo f(n) = g(n) + h(n), donde h(n) es la heurística y g(n) sería la función de costo. Este algoritmo ya no sería un greedy best-first search sino que se vuelve una búsqueda A*, que puede ser más costoso computacionalmente que el algoritmo greedy, pero puede encontrar soluciones más óptimas (el greedy no garantiza optimalidad). En este caso todos los movimientos cuestan 1, entonces esta nueva función tendría que optimizar el número de movimientos para ser el menor número posible. El algoritmo podría ser más interesante si cada movimiento tuviera un costo diferente, ya que la solución óptima no sería necesariamente la de menor número de movimientos.

## 3. ¿Qué sucede si hay múltiples salidas en el laberinto? ¿Cómo podrías modificar el algoritmo para manejar esto? Plantea una propuesta.
Esto significaría que habría varios estados de aceptación (varias salidas) y lo importante es llegar a una de ellas, sin importar cual sea. Ahora, habría que ver cuál sería la salida más cercana para que sea una solución óptima. Una propuesta sería usar la misma distancia de Manhattan desde el punto inicial hacia todas las posibles salidas y ver cual es la más cercana según esta heurística. Cuando se seleccione la salida más cercana ya se podrían ignorar las demás y ejecutar el algoritmo tal cual como está en este momento para llegar a dicha salida. Se podrían explorar otras heurísticas para ver cual es la mejor para resolver este problema (por ejemplo una distancia euclidiana), pero teniendo en cuenta que ya estamos manejando la distancia de Manhattan, empezaríamos con esta opción.

## 4. Modifica el laberinto por uno más grande y con otro tipo de obstáculo además de paredes. ¿Qué limitación encuentras en el algoritmo?
La primer limitación es que actualmente el algoritmo solo tiene en cuenta las paredes como obstáculos entonces habría que agregar la lógica para identificar los otros obstáculos. Ya dependiendo de las condiciones que tengan estos obstáculos, las limitaciones pueden surgir.
Por ejemplo: si el nuevo obstáculo implica que el costo de moverse a través de él aumente, entonces el algoritmo actual (greedy) no encontraría una solución muy adecuada en términos de costos porque la heurística actual solo tiene en cuenta la distancia hacia la salida pero no los costos de los movimientos para llegar a ella. Si el nuevo obstáculo actúa como una pared, entonces el algoritmo actual podría seguir fuincionando.
Ahora, en cuanto al tamaño del mapa, el algoritmo solo tiene en cuenta la distancia a la salida, pero desconoce el número o posición de los obstáculos. Esto puede hacer que el algoritmo se encuentre con callejones sin salida o que pueda explorar mucho en direcciones equivocadas, lo que lo obligaría a retroceder y explorar otras rutas. Esto sumado a que no se tiene en cuenta el costo de los movimientos implicaría que la solución que encuentre el algoritmo puede estar muy alejada de la solución óptima.
